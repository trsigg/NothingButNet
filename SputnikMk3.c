#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Yaw,            sensorGyro)
#pragma config(Sensor, in2,    Repeater,       sensorAnalog)
#pragma config(Sensor, dgtl1,  Flywheel,       sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  LEFT,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  RIGHT,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           intkae,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FrontRightDrive, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           BackRightDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           BottomRightLaunch, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           TopRightLaunch, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           TopLeftLaunch, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           BottomLeftLaunch, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           BackLeftDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FrontLeftDrive, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          feed,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float Kp = 12.6; //TO TUNE
int Error = 0;
float Kerror;
float Ki  = 0.001; //TO TUNE
float Integral = 0;
float Kintegral;
float Kd = 3.4; //TO TUNE
int DeltaE = 0;
float Kdeltae;
int power = 0;
float Flyspeed = 0;
int powerlevel = 100;
int TargetSpeed = 0;
int setpower = 0;
int TargetSpeeds[5] = {0, 82, 103, 80, 80};//Off, Skillz, Long, 1st, 2nd
int setpowers[5] = {0, 70, 96, 65, 65};
TVexJoysticks buttons[5] = {Btn8D, Btn7U, Btn7R, Btn7D, Btn7L};
int PrevError;
int Flypower = 0;
float realBias = 0;
int n;
int i;
long cumBias = 0;
//int XLocations[12] = {1,2,3,4,5,6,7,8,9,10,11,12}; //Coordinates of Field objects
//int YLocations[12] = {1,2,3,4,5,6,7,8,9,10,11,12};
//int powers[12] = {1,2,3,4,5,6,7,8,9,10,11,12};
//float speeds[12] = {1,2,3,4,5,6,7,8,9,10,11,12};

task motorcontrol()
{
	SensorValue[Flywheel] = 0;
	while(1)
	{
		Flyspeed = abs(SensorValue[Flywheel]);
		Error = TargetSpeed - Flyspeed;
		DeltaE = Error - PrevError;
		PrevError = Error;
		Integral += (Error + PrevError)/2;
		Kintegral = Ki*Integral;
		Kerror = Kp*Error;
		Kdeltae = Kd*DeltaE;
		power = setpower + Kp*Error + Ki*Integral + Kd*DeltaE;
		SensorValue[Flywheel] = 0;
		wait1Msec(17);
	}
}

//task Location
//{
//}

task main()
{
	SensorType[Yaw] = sensorNone;
	cumBias=0;
  for(i=0;i<2000;i++)
  {
    cumBias += SensorValue[Yaw];
    wait1Msec(1);
  }
  realBias = cumBias / 2000;
  SensorType[Yaw] = sensorGyro;
	SensorBias[Yaw] = realBias;
	startTask(motorcontrol);
	while(1)
	{
		Flypower = powerlevel*vexRT[Btn8D];
		motor[intkae] = (vexRT[Btn6U]*127 + vexRT[Btn6D]*-127);
		motor[feed] = (vexRT[Btn5U]*127 + vexRT[Btn5D]*-127);
		motor[TopLeftLaunch] = Flypower;
		motor[TopRightLaunch] = Flypower;
		motor[BottomLeftLaunch] = Flypower;
		motor[BottomRightLaunch] = Flypower;
		motor[BackLeftDrive] = vexRT[Ch3];
		motor[FrontLeftDrive] = vexRT[Ch3];
		motor[BackRightDrive] = vexRT[Ch2];
		motor[FrontRightDrive] = vexRT[Ch2];
		for (int i = 0; i < 5; i++)
		{
			n = (vexRT[buttons[i]] == 1 ? i : n);
		}
		if(n == 0)
		{
			Integral = 0;
		}
		TargetSpeed = TargetSpeeds[n];
		setpower = setpowers[n];
		Integral = vexRT[Btn8D] == 1 ? 0 : Integral;
	}
}
