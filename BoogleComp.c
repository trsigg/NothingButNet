#pragma config(Sensor, dgtl1,  Flywheel,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  LEFT,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  RIGHT,          sensorQuadEncoder)
#pragma config(Motor,  port1,           intkae,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FLeft,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           BLeft,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           Fly1,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Fly2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Fly3,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           Fly4,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BRight,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FRight,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          feed,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

float Kp = 1.1; //TO TUNE
int Error = 0;
float Ki  = 0.001; //TO TUNE
float Integral = 0;
float Kd = 1.5; //TO TUNE
int DeltaE = 0;
int power = 0;
float Flyspeed = 0;
int TargetSpeed = 0;
int PrevError;
int setpower = 0;
float PowerPercentLeft;
float PowerPercentRight;
float MotorLeftPower = 127;
float MotorRightPower = 127;
float RightSpeed;
float LeftSpeed;
float LastLeftMotorValue;
float LastRightMotorValue;

int Rightpower;
int Leftpower;
int Flypower = 0;
int ToggleFly = 0;


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task Drive()
{
	while(1==1)
	{
		PowerPercentRight = ((Rightpower * 100)/127);
		PowerPercentLeft = ((Leftpower * 100)/127);
		motor[BRight] = (MotorRightPower * PowerPercentRight/100);
		motor[BLeft] = (MotorLeftPower * PowerPercentLeft/100);
		motor[FRight] = (MotorRightPower * PowerPercentRight/100);
		motor[FLeft] = (MotorLeftPower * PowerPercentLeft/100);
		do
		{
			RightSpeed = (SensorValue[RIGHT] - LastRightMotorValue);
			LeftSpeed = (SensorValue[LEFT] - LastLeftMotorValue);
			LastRightMotorValue = SensorValue[RIGHT];
			LastLeftMotorValue = SensorValue[LEFT];
			wait1Msec(250);
		}
		while(1==1);
		if((RightSpeed/PowerPercentRight) > (LeftSpeed/PowerPercentLeft))
		{
			if (MotorLeftPower < 127)
			{
				MotorLeftPower = (MotorLeftPower + 1);
			}
			else
			{
				MotorRightPower = (MotorRightPower - 1);
			}
		}
		else if((RightSpeed/PowerPercentRight) < (LeftSpeed/PowerPercentLeft))
		{
			if (MotorRightPower < 127)
			{
				MotorRightPower = (MotorRightPower + 1);
			}
			else
			{
				MotorLeftPower = MotorLeftPower - 1;
			}
		}
	}
}

task motorcontrol()
{
	SensorValue[Flywheel] = 0;
	while(1)
	{
		Flyspeed = abs(SensorValue[Flywheel]);
		Error = TargetSpeed - Flyspeed;
		DeltaE = Error - PrevError;
		Integral += ((Error + PrevError)/2)*ToggleFly;
		power = setpower + Kp*Error + Ki*Integral + Kd*DeltaE;
		SensorValue[Flywheel] = 0;
		wait1Msec(25);
	}
}

task autonomous()
{
	TargetSpeed = 950;
	setpower = 104;
	startTask(motorcontrol);
	motor[Fly1] = power;
	motor[Fly2] = power;
	motor[Fly3] = power;
	motor[Fly4] = power;
	wait1Msec(1000);
	clearTimer(T1);
	while(true)
	{
		if(abs(Error) < 60)
		{
			motor[intkae] = 127;
			motor[feed] = 127;
		}
		else
		{
			motor[intkae] = 0;
			motor[feed] = 0;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////



task usercontrol()
{
	SensorValue[LEFT] = 0;
	SensorValue[RIGHT] = 0;
	startTask(motorcontrol);
	while(1)
	{
		Flypower = (sgn(power) > 0 ? power : 0 )*(ToggleFly ? 1 : 0);
		Rightpower = vexRT[Ch2];
		Leftpower = vexRT[Ch3];
		startTask(Drive);
		motor[intkae] = vexRT[Btn5U]*127 + vexRT[Btn5D]*-127;
		motor[feed] = vexRT[Btn6U]*127 + vexRT[Btn6D]*-127;
		motor[Fly1] = Flypower;
		motor[Fly2] = Flypower;
		motor[Fly3] = Flypower;
		motor[Fly4] = Flypower;
		if(vexRT[Btn8D] == 1)//Toggle won't initiate until button is depressed
		{
			ToggleFly = ((ToggleFly < 1) ? 1 : 0);
			waitUntil(vexRT[Btn8D] == 0);
		}
		if(vexRT[Btn7U] == 1)//Long Range
		{
			TargetSpeed = 209;
			setpower = 65;
			waitUntil(vexRT[Btn7U] == 0);
		}
		if(vexRT[Btn7R] == 1)//Net Range
		{
			TargetSpeed = 810;
			setpower = 53;
			waitUntil(vexRT[Btn7R] == 0);
		}
		if(vexRT[Btn7L] == 1)//Middle Range
		{
			TargetSpeed = 753;
			setpower = 45;
			waitUntil(vexRT[Btn7L] == 0);
		}
	}
}
