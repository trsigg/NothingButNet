#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Yaw,            sensorGyro)
#pragma config(Sensor, in2,    XA,             sensorAccelerometer)
#pragma config(Sensor, in3,    YA,             sensorAccelerometer)
#pragma config(Sensor, in4,    RightLine,      sensorLineFollower)
#pragma config(Sensor, in5,    LeftLine,       sensorLineFollower)
#pragma config(Sensor, in6,    Choice1,        sensorPotentiometer)
#pragma config(Sensor, in7,    Choice2,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  FlySpin,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  LeftSonar,      sensorSONAR_inch)
#pragma config(Sensor, dgtl5,  RightSonar,     sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  BallLaunch,     sensorTouch)
#pragma config(Sensor, dgtl8,  BallNext,       sensorTouch)
#pragma config(Sensor, dgtl9,  BallMiddle,     sensorTouch)
#pragma config(Sensor, dgtl10, BallLast,       sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           Intake,        tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           FrontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           BackLeft,      tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           MiddleLeft,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           TBLeft,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           TMRight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           BottomRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           BackRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,           FrontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port10,          Feed,          tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*float YAccel;
float XAccel;
float YAccelPrev;
float XAccelPrev;
float YSpeed;
float XSpeed;
float YSpeedPrev;
float XSpeedPrev;
float YPosition = -36;
float XPosition = 60;
float YPositionPrev;
float XPositionPrev;
float IntXAccel;
float IntXSpeed;
float IntYAccel;
float IntYSpeed;
float g = (386.09)/(405000000);*/
int Flyspeed;
int Flystep;
int FlyWheelSpeed;
int LastFlyspin;
int NormalSpeed;
int FlyOn;
float PowerPercentFrontLeft;
float PowerPercentFrontRight;
float PowerPercentBackLeft;
float PowerPercentBackRight;
int MotorFrontLeftPower = 127;
int MotorFrontRightPower = 127;
int MotorBackLeftPower = 127;
int MotorBackRightPower = 127;
int FrontRightSpeed;
int FrontLeftSpeed;
int BackRightSpeed;
int BackLeftSpeed;
int LastFrontLeftMotorValue;
int LastFrontRightMotorValue;
int LastBackLeftMotorValue;
int LastBackRightMotorValue;
int SensorSetup = 0;



/*task Position()
{
	while(1==1)
	{
		XAccel = (cosDegrees(Yaw/10) *  YA * (g)) + (sinDegrees(Yaw/10) * XA * (g)); //Total X and Y Motion
		YAccel = (cosDegrees(Yaw/10) *  XA * (g)) + (sinDegrees(Yaw/10) * YA * (g));
		IntYAccel = YAccel - YAccelPrev; //Definte Integral
		IntXAccel = XAccel - XAccelPrev;
		YSpeed = IntYAccel + YSpeedPrev; // Find Speed
		XSpeed = IntXAccel + XSpeedPrev;
		IntYSpeed = YSpeed - YSpeedPrev; // Integrate Speed
		IntXSpeed = XSpeed - XSpeedPrev;
		YPosition = IntYSpeed + YPositionPrev; // Find Position
		XPosition = IntXSpeed + XPositionPrev;
		YAccelPrev = YAccel; // Set everything to last value
		XAccelPrev = XAccel;
		YSpeedPrev = YSpeed;
		XSpeedPrev = XSpeed;
		YPositionPrev = YPosition;
		XPositionPrev = XPosition;
		wait1Msec(1); // For Accuracy
	}
}*/

task FlyWheel()
{
	while(true)
	{
		if (vexRT[Btn7D] == 1 && Flystep == 0)//Toggle on
  	{
  		Flystep = 1;
  		FlyOn = 1;
  	}
  	if (vexRT[Btn7D] == 1 && Flystep == 3)//Toggle off
  	{
  		Flystep = 2;
  		FlyOn = 0;
  	}
  	if (vexRT[Btn7D] == 0 && Flystep == 1)//Hold toggle on
  	{
  		Flystep = 3;
  		FlyOn = 1;
  	}
  	if (vexRT[Btn7D] == 0 && Flystep == 2)//Hold toggle off
  	{
  		Flystep = 0;
  		FlyOn = 0;
  	}
  	if (FlyOn == 1)//Start Flywheel
  	{
  		if(Flyspeed < 33)
  		{
  			Flyspeed = Flyspeed + 1;
  			wait1Msec(3);
  		}
  		else if(Flyspeed > 66)
  		{
  			Flyspeed = Flyspeed + 1;
  			wait1Msec(2);
  		}
  		else if(Flyspeed > 100)
  		{
  			Flyspeed = Flyspeed + 1;
  			wait1Msec(1);
  		}
  		if((FlyWheelSpeed - NormalSpeed)<= 5)//BangBang up when speed drops
  		{
  			Flyspeed = 127;
  		}
  		else//Normal Speed
  		{
  			Flyspeed = 100;
  		}
  	}
  	else//Off
  	{
  		Flyspeed = 0;
  	}
	}
	do//Measure Speed
	{
		FlyWheelSpeed = (SensorValue[FlySpin] - LastFlyspin);
		LastFlyspin = SensorValue[FlySpin];
		wait1Msec(50);
	}
	while(true);
}

task Drive()
{
	while(true)
	{
		PowerPercentFrontRight = (((vexRT[Ch2] - vexRT[Ch4]) * 100)/127);
		PowerPercentFrontLeft = (((vexRT[Ch3] - vexRT[Ch4]) * 100)/127);
		PowerPercentBackRight = (((vexRT[Ch2] + vexRT[Ch1]) * 100)/127);
		PowerPercentBackLeft = (((vexRT[Ch3] + vexRT[Ch1]) * 100)/127);
		motor[FrontRight] = (MotorFrontRightPower * PowerPercentFrontRight/100);
		motor[BackRight] = (MotorBackRightPower * PowerPercentBackRight/100);
		motor[FrontLeft] = (MotorFrontLeftPower * PowerPercentFrontLeft/100);
		motor[BackLeft] = (MotorBackLeftPower * PowerPercentBackLeft/100);
		do
		{
			FrontRightSpeed = (nMotorEncoder[FrontRight] - LastFrontRightMotorValue);
			FrontLeftSpeed = (nMotorEncoder[FrontLeft] - LastFrontLeftMotorValue);
			BackRightSpeed = (nMotorEncoder[BackRight] - LastBackRightMotorValue);
			BackLeftSpeed = (nMotorEncoder[BackLeft] - LastBackLeftMotorValue);
			LastFrontRightMotorValue = nMotorEncoder[FrontRight];
			LastFrontLeftMotorValue = nMotorEncoder[FrontLeft];
			LastBackRightMotorValue = nMotorEncoder[BackRight];
			LastBackLeftMotorValue = nMotorEncoder[BackLeft];
			wait1Msec(250);
		}
		while(1==1);
		if(FrontRightSpeed < 127 && (FrontRightSpeed < FrontLeftSpeed || FrontRightSpeed < BackLeftSpeed || FrontRightSpeed < BackRightSpeed))
		{
			MotorFrontRightPower = (MotorFrontRightPower + 1);
		}
		else if(FrontLeftSpeed < 127 && (FrontLeftSpeed < FrontRightSpeed || FrontLeftSpeed < BackLeftSpeed || FrontLeftSpeed < BackRightSpeed))
		{
			MotorFrontLeftPower = (MotorFrontLeftPower + 1);
		}
		else if(BackLeftSpeed < 127 && (BackLeftSpeed < FrontLeftSpeed || BackLeftSpeed < FrontRightSpeed || BackLeftSpeed < BackRightSpeed))
		{
			MotorBackLeftPower = (MotorBackLeftPower + 1);
		}
		else if(BackRightSpeed < 127 && (BackRightSpeed < FrontLeftSpeed || BackRightSpeed < BackLeftSpeed || BackRightSpeed < FrontRightSpeed))
		{
			MotorBackRightPower = (MotorBackRightPower + 1);
		}
		else if(FrontRightSpeed > FrontLeftSpeed || FrontRightSpeed > BackLeftSpeed || FrontRightSpeed > BackRightSpeed)
		{
			MotorFrontRightPower = (MotorFrontRightPower - 1);
		}
		else if(FrontLeftSpeed > FrontRightSpeed || FrontLeftSpeed > BackLeftSpeed || FrontLeftSpeed > BackRightSpeed)
		{
			MotorFrontLeftPower = (MotorFrontLeftPower - 1);
		}
		else if(BackLeftSpeed > FrontLeftSpeed || BackLeftSpeed > FrontRightSpeed || BackLeftSpeed > BackRightSpeed)
		{
			MotorBackLeftPower = (MotorBackLeftPower - 1);
		}
		else if(BackRightSpeed > FrontLeftSpeed || BackRightSpeed > BackLeftSpeed || BackRightSpeed > FrontRightSpeed)
		{
			MotorBackRightPower = (MotorBackRightPower - 1);
		}
	}
}

task main()
{
	while(SensorSetup != 1)
	{
		SensorType(Yaw) = sensorNone;
		wait1Msec(4000);
		SensorType(Yaw) = sensorGyro;
		SensorSetup = 1;
	}
	while(true)
	{
		motor[MiddleLeft] = Flyspeed;
		motor[TBLeft] = Flyspeed;
		motor[TMRight] = Flyspeed;
		motor[BottomRight] = Flyspeed;
		startTask(FlyWheel);
		startTask(Drive);
		//startTask(Position);
		if(vexRT[Btn5U] == 1)
		{
			motor[Feed] = 127;
		}
		else if(vexRT[Btn5D] == 1)
		{
			motor[Feed] = -127;
		}
		else
		{
			motor[Feed] = 0;
		}
		if(vexRT[Btn6U] == 1)
		{
			motor[Intake] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[Intake] = -127;
		}
		else
		{
			motor[Intake] = 0;
		}
	}
}
